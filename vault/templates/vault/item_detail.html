{% extends 'vault/base.html' %}

{% block title %}{{ item.title }} â€” SecurePad{% endblock %}

{% block content %}
<div class="row">
    <div class="col-md-8">
        <div class="card shadow-sm">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-start">
                    <div>
                        <h3 class="card-title mb-1">{{ item.title }}</h3>
                        <div class="text-muted small">{{ item.get_item_type_display }} &middot; {{ item.created_at|date:'M d, Y H:i' }}</div>
                    </div>
                    <div>
                        <a class="btn btn-outline-secondary btn-sm" href="{% url 'vault:dashboard' %}"><i class="bi bi-arrow-left"></i> Back</a>
                    </div>
                </div>

                <hr>

                <div>
                    {% if item.item_type == 'SECRET' %}
                        <div id="secret-content" class="mb-3">
                            <button id="toggle-secret" class="btn btn-sm btn-primary mb-2">Show secret</button>
                                <pre id="secret-pre" class="secret-value d-none p-3 border rounded bg-light" data-ct="{% if encrypted_b64 %}{{ encrypted_b64 }}{% endif %}">{{ item.decrypted_display }}</pre>
                        </div>
                    {% else %}
                        <pre class="p-3 border rounded bg-light">{{ item.decrypted_display }}</pre>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
function urlBase64ToBase64(urlBase64) {
    let b64 = urlBase64.replace(/-/g, '+').replace(/_/g, '/');
    while (b64.length % 4 !== 0) {
        b64 += '=';
    }
    return b64;
}

async function tryClientDecrypt() {
    const pre = document.getElementById('secret-pre');
    if (!pre) return;
    const ctB64 = pre.dataset.ct;
    if (!ctB64) return;
    // If server already decrypted, do nothing
    if (pre.textContent && pre.textContent.trim() && pre.textContent !== 'Error decrypting') return;
    try {
        const r = await fetch('{% url "vault:get_raw_dek" %}');
        if (!r.ok) return;
        const data = await r.json();
        const dekB64 = data.dek;
        const keyBytes = Uint8Array.from(atob(urlBase64ToBase64(dekB64)), c => c.charCodeAt(0));
        const key = await crypto.subtle.importKey('raw', keyBytes, 'AES-GCM', false, ['decrypt']);
        // decode ciphertext into Uint8Array
        const fullB64 = urlBase64ToBase64(ctB64.replace(/\s+/g, ''));
        const bytes = Uint8Array.from(atob(fullB64), c => c.charCodeAt(0));
        const iv = bytes.slice(0,12);
        const ciphertext = bytes.slice(12);
        const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
        const dec = new TextDecoder().decode(pt);
        pre.textContent = dec;
        pre.classList.remove('d-none');
    } catch (err) {
        // decryption failed or not AES-GCM format; ignore silently
    }
}

document.addEventListener('DOMContentLoaded', function(){
    tryClientDecrypt();
});
</script>
{% endblock %}
